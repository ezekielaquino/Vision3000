{"version":3,"file":"Vision3000.js","sources":["../src/RequestImage.js","../src/index.js"],"sourcesContent":["const RequestImage = src => {\n  const image = new Image();\n\n  return new Promise((resolve, reject) => {\n    image.src = src;\n    image.onload = resolve(image);\n    image.onerror = reject;\n  });\n}\n\n\nexport default RequestImage;","import RequestImage from './RequestImage';\n\n\n/**\n  VISION3000\n  2018\n  A proof of concept WIP\n  It's usable, but use it at your own risk!\n  Note: if you're planning to use this in Safari,\n  then you have to polyfill IntersectionObserver\n\n  yarn add intersection-observer\n  and just import 'intersection-observer' (2.5kb)\n  then you're good to go\n*/\nclass Vision3000 {\n  constructor(options = {}) {\n    this.options = {\n      rootMargin: options.rootMargin || '0px 0px',\n      threshold: options.threshold || [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    };\n    this.onIntersect = options.onIntersect;\n    this.FPS = 2;\n    this.init();\n  }\n\n  init() {\n    window.VISION3K = {\n      observer: new IntersectionObserver(entries => { this.intersect(entries) }, this.options),\n      observe: this.observe,\n      onIntersect: this.onIntersect,\n      observables: [],\n      inView: [],\n      viewed: [],\n      errors: [],\n    };\n\n    this.scrollIntent();\n  }\n\n  intersect(entries) {\n    entries.forEach(entry => {\n      const id = entry.target.observeId;\n\n      window.VISION3K.inView = window.VISION3K.inView.filter(item => item !== id);\n\n      if (entry.isIntersecting) window.VISION3K.inView.push(id);\n    });\n\n    const onIntersect = window.VISION3K.onIntersect || this.onIntersect;\n    if (typeof onIntersect === 'function') onIntersect(window.VISION3K.inView, window.VISION3K.viewed);\n  }\n\n  loadImages() {\n    window.VISION3K.inView.forEach(index => {\n      if (!window.VISION3K.viewed.includes(index)) {\n        const element = window.VISION3K.observables[index];\n        const image = element.querySelector('img');\n\n        window.VISION3K.viewed.push(index);\n\n        if (typeof element.onLoadStart === 'function') element.onLoadStart(element, image, window.VISION3K.viewed);\n\n        RequestImage(image.dataset.src)\n          .then(img => {\n            img.classList = image.classList;\n\n            img.decode().then(() => {\n              image.replaceWith(img);\n              if (typeof element.onLoad === 'function') element.onLoad(element, image, window.VISION3K.viewed);\n            });\n          })\n          .catch(e => {\n             console.error(`Failed to load image ${image.dataset.src}`);\n          });\n      }\n    });\n  }\n\n  scrollIntent() {\n   this.scrollProps = {\n      scrollSpeed: 0,\n      isHalted: true,\n      prevScrollSpeed: 0,\n      prevY: 0,\n    };\n\n    const setScrollProps = () => {\n      clearTimeout(this.timeout);\n\n      this.timeout = setTimeout(() => {\n        const scrollSpeed = Math.abs(window.scrollY - this.scrollProps.prevY);\n        const isHalted = scrollSpeed === 0;\n\n        this.scrollProps = {\n          scrollSpeed,\n          isHalted,\n          prevY: window.scrollY,\n          prevScrollSpeed: this.scrollProps.scrollSpeed,\n        };\n\n        if (isHalted) this.loadImages();\n\n        setScrollProps();\n      }, 1000 / this.FPS);\n    }\n\n    setScrollProps();\n  }\n\n  observe(element, options) {\n    window.VISION3K.observables.push(element);\n\n    element.observeId = window.VISION3K.observables.length - 1;\n    element.onLoadStart = options.onLoadStart;\n    element.onLoad = options.onLoad;\n\n    window.VISION3K.observer.observe(element);\n  }\n}\n\nexport const initVision3000 = options => new Vision3000(options);\n\n\nexport default Vision3000;"],"names":["const","Vision3000","options","rootMargin","threshold","this","onIntersect","FPS","init","VISION3K","observer","IntersectionObserver","entries","intersect","observe","scrollIntent","forEach","entry","id","target","observeId","inView","window","filter","item","isIntersecting","push","viewed","loadImages","index","includes","element","observables","image","querySelector","onLoadStart","src","Image","Promise","resolve","reject","onload","onerror","RequestImage","dataset","then","img","classList","decode","replaceWith","onLoad","catch","e","console","error","scrollProps","setScrollProps","clearTimeout","timeout","setTimeout","scrollSpeed","Math","abs","scrollY","prevY","isHalted","prevScrollSpeed","length"],"mappings":"AAAAA,ICeMC,EACJ,SAAYC,2BACLA,SACHC,WAAYD,EAAQC,YAAc,oBACvBD,EAAQE,YAAc,EAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,GAAK,MAAU,IAErFC,KAAKC,YAAcJ,EAAQI,YAC3BD,KAAKE,IAAM,EACXF,KAAKG,oBAGPA,kCACSC,UACLC,SAAU,IAAIC,8BAAqBC,GAAaP,EAAKQ,UAAUD,IAAYP,KAAKH,SAChFY,QAAST,KAAKS,QACdR,YAAaD,KAAKC,0DAOpBD,KAAKU,4BAGPF,mBAAUD,GACRA,EAAQI,iBAAQC,OACRC,EAAKD,EAAME,OAAOC,iBAEjBX,SAASY,OAASC,OAAOb,SAASY,OAAOE,gBAAOC,UAAQA,IAASN,IAEpED,EAAMQ,gBAAgBH,OAAOb,SAASY,OAAOK,KAAKR,KAGxDlB,IAAMM,EAAcgB,OAAOb,SAASH,aAAeD,KAAKC,YAC7B,mBAAhBA,GAA4BA,EAAYgB,OAAOb,SAASY,OAAQC,OAAOb,SAASkB,qBAG7FC,6BACSnB,SAASY,OAAOL,iBAAQa,GAC7B,IAAKP,OAAOb,SAASkB,OAAOG,SAASD,GAAQ,CAC3C7B,IAAM+B,EAAUT,OAAOb,SAASuB,YAAYH,GACtCI,EAAQF,EAAQG,cAAc,cAE7BzB,SAASkB,OAAOD,KAAKG,GAEO,mBAAxBE,EAAQI,aAA4BJ,EAAQI,YAAYJ,EAASE,EAAOX,OAAOb,SAASkB,iBD7DtFS,GACnBpC,IAAMiC,EAAQ,IAAII,MAElB,OAAO,IAAIC,iBAASC,EAASC,GAC3BP,EAAMG,IAAMA,EACZH,EAAMQ,OAASF,EAAQN,GACvBA,EAAMS,QAAUF,ICyDZG,CAAaV,EAAMW,QAAQR,KACxBS,cAAKC,GACJA,EAAIC,UAAYd,EAAMc,YAElBC,SAASH,gBACXZ,EAAMgB,YAAYH,GACY,mBAAnBf,EAAQmB,QAAuBnB,EAAQmB,OAAOnB,EAASE,EAAOX,OAAOb,SAASkB,YAG5FwB,eAAMC,GACJC,QAAQC,8BAA8BrB,EAAMW,+BAMvD7B,wCACMwC,yBACW,YACH,kBACO,QACV,GAGTvD,IAAMwD,aACJC,aAAapD,EAAKqD,SAElBrD,EAAKqD,QAAUC,sBACb3D,IAAM4D,EAAcC,KAAKC,IAAIxC,OAAOyC,QAAU1D,EAAKkD,YAAYS,OACzDC,EAA2B,IAAhBL,IAEZL,yBACHK,WACAK,EACAD,MAAO1C,OAAOyC,QACdG,gBAAiB7D,EAAKkD,YAAYK,aAGhCK,GAAU5D,EAAKuB,kBAGlB,IAAOvB,EAAKE,uBAMnBO,iBAAQiB,EAAS7B,UACRO,SAASuB,YAAYN,KAAKK,GAEjCA,EAAQX,UAAYE,OAAOb,SAASuB,YAAYmC,OAAS,EACzDpC,EAAQI,YAAcjC,EAAQiC,YAC9BJ,EAAQmB,OAAShD,EAAQgD,cAElBzC,SAASC,SAASI,QAAQiB"}